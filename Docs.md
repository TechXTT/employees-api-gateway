Проектът има следната архитектура:

- Има два сервиза: `auth` и `data`.
  - `auth` се грижи за управлението на потребителските идентификации, използвайки JWT бисквитки.
  - `data` се грижи за контрола на данните в проекта.
- `auth` сервизът ограничава достъпа до `data` сервиза.
- Комуникацията между двата сервиза се осъществява поотделно чрез gRPC с помощта на `api-gateway`.
- Всичко е реализирано на Go език. `api-gateway` използва `mux.Router` за обработка на заявките.
- В проекта има три контейнера: `api-gateway`, `auth-svc` и `data-svc`.

Конфигурацията в Kubernetes YAML формат включва:

- `Ingress` ресурс с име `combined-ingress`, който осигурява входна точка за достъп до приложението.
  - Използва се анотацията `nginx.ingress.kubernetes.io/affinity` за cookie-based session affinity.
  - Използва се анотацията `nginx.ingress.kubernetes.io/load-balance` за най-малко натоварен балансьор.
- `nginx-ingress-controller` деплоймънт с три реплики, който осигурява работата на контролера на входния трафик.
- `combined-service` сервиз, който служи като LoadBalancer за достъп до сервизите.
- `combined-deployment` деплоймънт, който съдържа три контейнера: `api-gateway`, `auth-svc` и `data-svc`.

Разгледайки използваните технологии в проекта, ето и кратко обяснение за всяка от тях:

- **JWT и cookie**: Използва се JWT (JSON Web Token) и бисквитки за управление на потребителските идентификации в `auth` сервиза. JWT позволява сигурно предаване на информацията за потребителската идентичност между различни компоненти на системата, докато бисквитките осигуряват съхранение на тази информация на клиентската страна.

- **gRPC**: Комуникацията между `auth` и `data` сервизите се извършва чрез gRPC. gRPC е модерен механизъм за изграждане на разпределени системи, който използва Protobuf за сериализация на данните и предоставя мощен начин за взаимодействие между микросервизите.

- **api-gateway**: `api-gateway` е отговорен за обработката на входните HTTP заявки и пренасочването им към съответните сервизи. Той използва `mux.Router`, който е маршрутизатор за Go език, за да дефинира пътищата на API-то и да ги свърже със съответните функции и обработчици.

- **Kubernetes Ingress**: `Ingress` ресурсът в Kubernetes служи за управление на входния трафик и маршрутизация към подходящите сервизи. В случая `combined-ingress` се конфигурира с анотации, като `affinity`, `load-balance` и други, които позволяват балансиране на натоварването и управление на сесиите.

- **nginx-ingress-controller**: `nginx-ingress-controller` е контролер на входния трафик, базиран на NGINX, който се използва за обработка на заявките на входния ингрес. Той осигурява интелигентно разпределение на заявките и гарантира, че те достигат до правилните сервизи.

- **LoadBalancer сервиз**: `combined-service` е типът на сервиза, дефиниран като LoadBalancer. Това позволява Kubernetes да автоматично разпределя трафика между репликите на сервиза и осигурява висока наличност и отказоустойчивост.

- **Deployment**: Използват се деплоймънти в Kubernetes за дефиниране на жизнения цикъл и мащабирането на приложението. В случая `combined-deployment` дефинира деплоймънт за три контейнера - `api-gateway`, `auth-svc` и `data-svc`, като указва репликите и ресурсите за всяка от тях. Това осигурява стабилност и разпределение на натоварването върху различните инстанции на контейнерите.
